package aqs.reentrant.readwrite;

/**
 * @Author yangwentian5
 * @Date 2022/3/10 16:20
 * 如果同一个线程先获取读锁，再获取写锁会，在tryAcquire()方法中，如果读锁被获取的次数不为0（c != 0 && w == 0），返回false，返回之后外层方法会让当前线程阻塞
 * 先读后写，一个线程占有读锁后，其它线程还是可以占有读锁的，这时候如果在其它线程占有读锁之前让自己占有了写锁，其它线程又不能占有读锁了，这段程序会非常难实现，逻辑也很奇怪，
 * 所以，设计成只要一个线程占有了读锁，其它线程包括它自己都不能再获取写锁。
 *
 * 如果同一个线程先获取写锁，再获取读锁，那么在tryAcquireShared()方法中，第一个红框处并不会返回，因为不满足getExclusiveOwnerThread() != current；
 * 第二个红框处如果原子更新成功就说明获取了读锁，然后就会执行第三个红框处的代码把其重入次数更改为1
 * 先写后读，一个线程占有写锁后，其它线程是不能占有任何锁的，这时候，即使自己占有一个读锁，对程序的逻辑也不会有任何影响，
 * 所以，一个线程占有写锁后是可以再占有读锁的，只是这个时候其它线程依然无法获取读锁。
 *
 * 如果你仔细思考上面的逻辑，你会发现一个线程先占有读锁后占有写锁，会有一个很大的问题——锁无法被释放也无法被获取了。
 * 这个线程先占有了读锁，然后自己再占有写锁的时候会阻塞，然后它就自己把自己搞死了，进而把其它线程也搞死了，它无法释放锁，其它线程也无法获得锁了。
 */
public class ReentrantReadWriteLockTest {
}
